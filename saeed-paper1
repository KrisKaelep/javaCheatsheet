paper1
http://www.eis.mdx.ac.uk/research/PhDArea/saeed/paper1.pdf

	Programming ability
is not known to be correlated with age, with sex, or with educational attainment; nor has it
been found to be correlated with any of the aptitudes measured in conventional ‘intelligence’ or
‘problem-solving-ability’ tests.

	A study undertaken by nine institutions in six countries [22] looked
at the programming skills of university computer science students at the end of their first year of
study. All the participants were shocked by the results, which showed that at the conclusion of
their introductory courses many students still did not know how to program.
	“Unfortunately, many students find it difficult to learn [to program]. Even universities
that can select from among the best students report difficulties in teaching Java.” [9]
	Whatever the cause of the problem, it isn’t a lack of motivation on anybody’s part. Students joining
programming courses are enthusiastic to find out how a set of instructions can apparently impart
intelligence to an electronic machine, and teachers are keen to help them. But many find that they
cannot learn what they want to know, however hard they try. They struggle on to the end of the
course, for reasons of personal pride, family pressure or because of a lack of pastoral support and
a dearth of escape routes, disillusioned and with a growing sense of personal failure. Those who
can learn, on the other hand, are frustrated by the slow breeze of teaching, a wind tempered to the
struggling shorn lambs. Teachers become demoralised that once again they’ve failed to crack the
problem. Everybody tries their best, and almost everybody ends up unhappy – until the next year
when a new intake begins a new course with their motivational batteries fully charged.
	The cause isn’t to be found in inappropriate teaching materials or methods either. Essentially, the
computer science community has tried everything (see section 2) and nothing works. Graphics,
artificial intelligence, logic programming languages, OOP, C, C++, PROLOG, Miranda: you name
it, we’ve tried it. We’ve tried conventional teaching, lab-based learning by discovery and remedial
classes. We’ve tried enthusiasm and cold-eyed logical clarity. Nothing makes a difference. Even
the UK’s attempt in the 1980s to teach the whole UK population to program on the BBC Micro
ran into the sand.

	Programming teachers, being programmers and therefore formalists, are particularly prone to the
‘deductive fallacy’, the notion that there is a rational way in which knowledge can be laid out,
through which students should be led step-by-step. One of us even wrote a book [8] which attempted
to teach programming via formal reasoning. Expert programmers can justify their programs, he
argued, so let’s teach novices to do the same! The novices protested that they didn’t know what
counted as a justification, and Bornat was pushed further and further into formal reasoning. After
seventeen years or so of futile effort, he was set free by a casual remark of Thomas Green’s, who
observed “people don’t learn like that”, introducing him to the notion of inductive, exploratory
learning.
	Programmers, who on the whole like to point and click,
often expect that if you make programming point-and-click, then novices will find it easier. The
entire field can be summarised as saying “no, they don’t”.

	From experience it appears that there are three major semantic hurdles which trip up novice
imperative programmers. In order they are:
• assignment and sequence;
• recursion / iteration;
• concurrency.

	Formal logical proofs, and therefore programs – formal logical proofs that particular computations
are possible, expressed in a formal system called a programming language – are utterly meaningless.
To write a computer program you have to come to terms with this, to accept that whatever you
might want the program to mean, the machine will blindly follow its meaningless rules and come to
some meaningless conclusion.

	One of us (Bornat), disillusioned and dispirited after 30 years of trying to teach programming and
30 years of failure to eradicate the double hump, turned to formal logic. He had developed the
proof calculator Jape [7], and hoped that with its assistance students could learn to make formal
proofs. He speculated that the size of programming languages might confuse many students trying
to learn to program. Java, the teacher’s programming language of choice at the end of the 20th
century and at the beginning of the 21st, is defined loosely but at great length in several hundred
pages.4 Natural Deduction, on the other hand, can be defined precisely on a single side of a single
A4 sheet, in a normal font size. It is small and conceptually simple: surely it can be taught!
Well, up to a point it can, but the results were depressingly familiar. Figure 14 shows the results
from an in-course exam on formal logical proof. Unlike the examinations of section 3, students
were strongly discouraged from guessing, with negative marks for wrong answers in multiple-choice
questions and extensive unseen proof problems. As a consequence, two humps are clearly visible,
with one at 33-40 (about 50%) and another at 65-72 (about 85%). 